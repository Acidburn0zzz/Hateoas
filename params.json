{"name":"Hateoas","tagline":"A PHP library to support implementing representations for HATEOAS REST web services.","body":"Hateoas\r\n=======\r\n\r\n[![Build\r\nStatus](https://secure.travis-ci.org/willdurand/Hateoas.png)](http://travis-ci.org/willdurand/Hateoas)\r\n[![Scrutinizer Quality\r\nScore](https://scrutinizer-ci.com/g/willdurand/Hateoas/badges/quality-score.png?s=45b5a825f99de4d29c98b5103f59e060139cf354)](https://scrutinizer-ci.com/g/willdurand/Hateoas/)\r\n\r\n\r\n* [Installation](#installation)\r\n  - [Working With Symfony2](#working-with-symfony2)\r\n* [Usage](#usage)\r\n  - [Introduction](#introduction)\r\n  - [Configuring Links](#configuring-links)\r\n  - [Embedding Resources](#embedding-resources)\r\n  - [Dealing With Collections](#dealing-with-collections)\r\n  - [The Expression Language](#the-expression-language)\r\n    - [Context](#context)\r\n    - [Adding Your Own Context Variables](#adding-your-own-context-variables)\r\n  - [URL Generators](#url-generators)\r\n  - [Helpers](#helpers)\r\n    - [LinkHelper](#linkhelper)\r\n  - [Serializers & Formats](#serializers--formats)\r\n    - [The JsonHalSerializer](#the-jsonhalserializer)\r\n    - [The XmlSerializer](#the-xmlserializer)\r\n    - [The XmlHalSerializer](#the-xmlhalserializer)\r\n    - [Adding New Serializers](#adding-new-serializers)\r\n  - [The HateoasBuilder](#the-hateoasbuilder)\r\n    - [XML Serializer](#xml-serializer)\r\n    - [JSON Serializer](#json-serializer)\r\n    - [URL Generator](#url-generator)\r\n    - [Expression Evaluator/Expression Language](#expression-evaluatorexpression-language)\r\n    - [Relation Provider](#relation-provider)\r\n    - [(JMS) Serializer Specific](#jms-serializer-specific)\r\n    - [Others](#others)\r\n  - [Configuring a Cache Directory](#configuring-a-cache-directory)\r\n  - [Configuring Metadata Locations](#configuring-metadata-locations)\r\n* [Reference](#reference)\r\n  - [XML](#xml)\r\n  - [YAML](#yaml)\r\n  - [Annotations](#annotations)\r\n    - [@Relation](#relation)\r\n    - [@Route](#route)\r\n    - [@Embedded](#embedded)\r\n    - [@Exclusion](#exclusion)\r\n    - [@RelationProvider](#relationprovider)\r\n* [Internals](#internals)\r\n  - [Expression Functions](#expression-functions)\r\n\r\n\r\nInstallation\r\n------------\r\n\r\nThe recommended way to install Hateoas is through\r\n[Composer](http://getcomposer.org/). Require the `willdurand/hateoas` package\r\ninto your `composer.json` file:\r\n\r\n```json\r\n{\r\n    \"require\": {\r\n        \"willdurand/hateoas\": \"@stable\"\r\n    }\r\n}\r\n```\r\n\r\n**Protip:** you should browse the\r\n[`willdurand/hateoas`](https://packagist.org/packages/willdurand/hateoas)\r\npage to choose a stable version to use, avoid the `@stable` meta constraint.\r\n\r\nOtherwise, install the library and setup the autoloader yourself.\r\n\r\n### Working With Symfony2\r\n\r\nThere is a bundle for that! Install the\r\n[BazingaHateoasBundle](https://github.com/willdurand/BazingaHateoasBundle), and\r\nenjoy!\r\n\r\n\r\nUsage\r\n-----\r\n\r\n> **Important:** For those who use the `1.0` version, you can [jump to this\r\n> documentation\r\n> page](https://github.com/willdurand/Hateoas/blob/1.0/README.md#readme) as the\r\n> following documentation has been written for **Hateoas 2.0** and above.\r\n\r\n### Introduction\r\n\r\n**Hateoas** leverages the [Serializer](https://github.com/schmittjoh/serializer)\r\nlibrary to provide a nice way to build HATEOAS REST web services. HATEOAS stands\r\nfor **H**ypermedia **a**s **t**he **E**ngine **o**f **A**pplication **S**tate,\r\nand basically adds **hypermedia links** to your **representations** (i.e. your\r\nAPI responses). [HATEOAS is about the discoverability of actions on a\r\nresource](http://timelessrepo.com/haters-gonna-hateoas).\r\n\r\nFor instance, let's say you have a User API which returns a **representation**\r\nof a single _user_ as follow:\r\n\r\n```json\r\n{\r\n    \"user\": {\r\n        \"id\": 123,\r\n        \"first_name\": \"John\",\r\n        \"last_name\": \"Doe\"\r\n    }\r\n}\r\n```\r\n\r\nIn order to tell your API consumers how to retrieve the data for this specific\r\nuser, you have to add your very first **link** to this representation, let's\r\ncall it `self` as it is the URI for this particular user:\r\n\r\n```json\r\n{\r\n    \"user\": {\r\n        \"id\": 123,\r\n        \"first_name\": \"John\",\r\n        \"last_name\": \"Doe\",\r\n        \"_links\": {\r\n            \"self\": { \"href\": \"http://example.com/api/users/123\" }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nLet's dig into Hateoas now.\r\n\r\n\r\n### Configuring Links\r\n\r\nIn Hateoas terminology, **links** are seen as **relations** added to resources.\r\nIt is worth mentioning that **relations** also refer to **embedded resources**\r\ntoo, but this topic will be covered in the [Embedding\r\nResources](#embedding-resources) section.\r\n\r\nA link is a relation which is identified by a `name` (e.g. `self`) and that\r\nhas an `href` parameter:\r\n\r\n```php\r\nuse JMS\\Serializer\\Annotation as Serializer;\r\nuse Hateoas\\Configuration\\Annotation as Hateoas;\r\n\r\n/**\r\n * @Serializer\\XmlRoot(\"user\")\r\n *\r\n * @Hateoas\\Relation(\"self\", href = \"expr('/api/users/' ~ object.getId())\")\r\n */\r\nclass User\r\n{\r\n    /** @Serializer\\XmlAttribute */\r\n    private $id;\r\n    private $firstName;\r\n    private $lastName;\r\n\r\n    public function getId() {}\r\n}\r\n```\r\n\r\nIn the example above, we configure a `self` relation that is a link because of\r\nthe `href` parameter. Its value, which may look weird at first glance, will be\r\nextensively covered in [The Expression Language](#the-expression-language)\r\nsection, but it basically generates a URI.\r\n\r\nIn this section, [**annotations**](#annotations) are used to configure Hateoas.\r\nHowever, [**XML**](#xml) and [**YAML**](#yaml) formats are also supported. If\r\nyou wish, you can use plain PHP too.\r\n\r\n**Important:** you must configure both the Serializer and Hateoas the same way. E.g.\r\nif you use YAML for configuring Serializer, use YAML for configuring Hateoas.\r\n\r\nThe easiest way to try HATEOAS is with the `HateoasBuilder`. The builder has\r\nnumerous methods to configure the Hateoas serializer, but we won't dig into\r\nthem right now (see [The HateoasBuilder](#the-hateoasbuilder)).\r\nEverything works fine out of the box:\r\n\r\n```php\r\nuse Hateoas\\HateoasBuilder;\r\n\r\n$hateoas = HateoasBuilder::create()->build();\r\n\r\n$user = new User(42, 'Adrien', 'Brault');\r\n$json = $hateoas->serialize($user, 'json');\r\n$xml  = $hateoas->serialize($user, 'xml');\r\n```\r\n\r\nThe `$hateoas` object is an instance of `JMS\\Serializer\\SerializerInterface`,\r\ncoming from the Serializer library. Hateoas does not come with its own\r\nserializer, it simply hooks into the JMS Serializer.\r\n\r\nBy default, Hateoas uses the [Hypertext Application\r\nLanguage](http://stateless.co/hal_specification.html) (HAL) for JSON\r\nserialization. This specifies the *structure* of the response (e.g. that\r\n\"links\" should live under a `_links` key):\r\n\r\n```json\r\n{\r\n    \"id\": 42,\r\n    \"first_name\": \"Adrien\",\r\n    \"last_name\": \"Brault\",\r\n    \"_links\": {\r\n        \"self\": {\r\n            \"href\": \"/api/users/42\"\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nFor XML, [Atom Links](http://tools.ietf.org/search/rfc4287#section-4.2.7)\r\nare used by default:\r\n\r\n```xml\r\n<user id=\"42\">\r\n    <first_name><![CDATA[Adrien]]></first_name>\r\n    <last_name><![CDATA[Brault]]></last_name>\r\n    <link rel=\"self\" href=\"/api/users/42\"/>\r\n</user>\r\n```\r\n\r\nIt is worth mentioning that these formats are the **default ones**, not the\r\nonly available ones. You can use [different formats through different\r\nserializers, and even add your owns](#serializers--formats).\r\n\r\nNow that you know how to add **links**, let's see how to add **embedded\r\nresources**.\r\n\r\n### Embedding Resources\r\n\r\nSometimes, it's more efficient to embed related resources rather than\r\nlink to them, as it prevents clients from having to make extra requests to\r\nfetch those resources.\r\n\r\nAn **embedded resource** is a named **relation** that contains data, represented\r\nby the `embedded` parameter.\r\n\r\n```php\r\nuse JMS\\Serializer\\Annotation as Serializer;\r\nuse Hateoas\\Configuration\\Annotation as Hateoas;\r\n\r\n/**\r\n * ...\r\n *\r\n * @Hateoas\\Relation(\r\n *     \"manager\",\r\n *     href = \"expr('/api/users/' ~ object.getManager().getId())\",\r\n *     embedded = \"expr(object.getManager())\",\r\n *     exclusion = @Hateoas\\Exclusion(excludeIf = \"expr(object.getManager() === null)\")\r\n * )\r\n */\r\nclass User\r\n{\r\n    ...\r\n\r\n    /** @Serializer\\Exclude */\r\n    private $manager;\r\n}\r\n```\r\n\r\n**Note:** You will need to exclude the manager property from the serialization,\r\notherwise both the serializer and Hateoas will serialize it.\r\nYou will also have to exclude the manager relation when the manager is `null`,\r\nbecause otherwise an error will occur when creating the `href` link (calling\r\n`getId()` on `null`).\r\n\r\n**Tip:** If the manager property is an object that already has a `_self`\r\nlink, you can re-use that value for the `href` instead of repeating it here.\r\nSee [LinkHelper](#linkhelper).\r\n\r\n```php\r\n$hateoas = HateoasBuilder::create()->build();\r\n\r\n$user = new User(42, 'Adrien', 'Brault', new User(23, 'Will', 'Durand'));\r\n$json = $hateoas->serialize($user, 'json');\r\n$xml  = $hateoas->serialize($user, 'xml');\r\n```\r\n\r\nFor `json`, the HAL representation places these embedded relations inside\r\nan `_embedded` key:\r\n\r\n```json\r\n{\r\n    \"id\": 42,\r\n    \"first_name\": \"Adrien\",\r\n    \"last_name\": \"Brault\",\r\n    \"_links\": {\r\n        \"self\": {\r\n            \"href\": \"/api/users/42\"\r\n        },\r\n        \"manager\": {\r\n            \"href\": \"/api/users/23\"\r\n        },\r\n    },\r\n    \"_embedded\": {\r\n        \"manager\": {\r\n            \"id\": 23,\r\n            \"first_name\": \"Will\",\r\n            \"last_name\": \"Durand\",\r\n            \"_links\": {\r\n                \"self\": {\r\n                    \"href\": \"/api/users/23\"\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nIn XML, serializing `embedded` relations will create new elements:\r\n\r\n```xml\r\n<user id=\"42\">\r\n    <first_name><![CDATA[Adrien]]></first_name>\r\n    <last_name><![CDATA[Brault]]></last_name>\r\n    <link rel=\"self\" href=\"/api/users/42\"/>\r\n    <link rel=\"manager\" href=\"/api/users/23\"/>\r\n    <manager rel=\"manager\" id=\"23\">\r\n        <first_name><![CDATA[Will]]></first_name>\r\n        <last_name><![CDATA[Durand]]></last_name>\r\n        <link rel=\"self\" href=\"/api/users/23\"/>\r\n    </manager>\r\n</user>\r\n```\r\n\r\nThe tag name of an embedded resource is inferred from the\r\n[`@XmlRoot`](http://jmsyst.com/libs/serializer/master/reference/annotations#xmlroot)\r\nannotation (`xml_root_name` in YAML, `xml-root-name` in XML) coming from the\r\nSerializer configuration.\r\n\r\n### Dealing With Collections\r\n\r\nThe library provides several classes in the `Hateoas\\Representation\\*`\r\nnamespace to help you with common tasks. These are simple classes configured\r\nwith the library's annotations.\r\n\r\nThe `PaginatedRepresentation` and `CollectionRepresentation` classes are\r\nprobably the most interesting ones. These are helpful when your resource is\r\nactually a collection of resources (e.g. ``/users`` is a collection of users).\r\nThese help you represent the collection and add pagination and limits:\r\n\r\n```php\r\nuse Hateoas\\Representation\\PaginatedRepresentation;\r\nuse Hateoas\\Representation\\CollectionRepresentation;\r\n\r\n$paginatedCollection = new PaginatedRepresentation(\r\n    new CollectionRepresentation(\r\n        array($user1, $user2, ...),\r\n        'users', // embedded rel\r\n        'users' // xml element name\r\n    ),\r\n    'user_list', // route\r\n    array(), // route parameters\r\n    1, // page\r\n    20, // limit\r\n    4, // total pages\r\n    'page', // page route parameter name, optional, defaults to 'page'\r\n    'limit' // limit route parameter name, optional, defaults to 'limit'\r\n);\r\n\r\n$json = $hateoas->serialize($paginatedCollection, 'json');\r\n$xml  = $hateoas->serialize($paginatedCollection, 'xml');\r\n```\r\n\r\nThe `CollectionRepresentation` class allows you to dynamically configure the\r\ncollection resources rel, and the xml root element name.\r\n\r\nThe `PaginatedRepresentation` is designed to add `self`, `first`, and when\r\npossible `last`, `next`, and `previous` links.\r\n\r\nThe Hateoas library also provides a `PagerfantaFactory` to easily build\r\n`PaginatedRepresentation` from a\r\n[Pagerfanta](https://github.com/whiteoctober/Pagerfanta) instance. If you use\r\nthe Pagerfanta library, this is an easier way to create the collection objects:\r\n\r\n```php\r\nuse Hateoas\\Representation\\Factory\\PagerfantaFactory;\r\n\r\n$pagerfantaFactory   = new PagerfantaFactory(); // you can pass the page and limit parameters name\r\n$paginatedCollection = $pagerfantaFactory->create(\r\n    $pager,\r\n    'user_list',\r\n    array() // route parameters\r\n);\r\n\r\n$json = $hateoas->serialize($paginatedCollection, 'json');\r\n$xml  = $hateoas->serialize($paginatedCollection, 'xml');\r\n```\r\n\r\nYou would get the following JSON content:\r\n\r\n```json\r\n{\r\n    \"users\": [\r\n        { \"id\": 123 },\r\n        { \"id\": 456 }\r\n    ],\r\n    \"page\": 1,\r\n    \"limit\": 10,\r\n    \"pages\": 1,\r\n    \"_links\": {\r\n        \"self\": {\r\n            \"href\": \"/api/users?page=1&limit=10\"\r\n        },\r\n        \"first\": {\r\n            \"href\": \"/api/users?page=1&limit=10\"\r\n        },\r\n        \"last\": {\r\n            \"href\": \"/api/users?page=1&limit=10\"\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nAnd the following XML content:\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<collection page=\"1\" limit=\"10\" pages=\"1\">\r\n    <user id=\"123\"></user>\r\n    <user id=\"456\"></user>\r\n    <link rel=\"self\" href=\"/api/users?page=1&amp;limit=10\" />\r\n    <link rel=\"first\" href=\"/api/users?page=1&amp;limit=10\" />\r\n    <link rel=\"last\" href=\"/api/users?page=1&amp;limit=10\" />\r\n</collection>\r\n```\r\n\r\n### The Expression Language\r\n\r\nHateoas relies on the powerful Symfony\r\n[ExpressionLanguage](http://symfony.com/doc/current/components/expression_language/introduction.html)\r\ncomponent to retrieve values such as links, ids or objects to embed.\r\n\r\nBasically, each time you fill in a value (e.g. a Relation `href` in annotations\r\nor YAML), you can either pass a **hardcoded value** or an **expression**.\r\nIn order to use the Expression Language, you have to use the `expr()` notation:\r\n\r\n```php\r\n/**\r\n * @Hateoas\\Relation(\"self\", href = \"expr('/api/users/' ~ object.getId())\")\r\n */\r\n```\r\n\r\nYou can learn more about the Expression Syntax by reading the official\r\ndocumentation: [The Expression\r\nSyntax](http://symfony.com/doc/current/components/expression_language/syntax.html).\r\n\r\n#### Context\r\n\r\nNatively, a special variable named `object` is available in each expression, and\r\nrepresents the current object:\r\n\r\n```\r\nexpr(object.getId())\r\n```\r\n\r\nWe call such a variable a **context variable**.\r\n\r\nYou can add your own context variables to the Expression Language context by\r\nadding them to the `ExpressionEvaluator`.\r\n\r\n##### Adding Your Own Context Variables\r\n\r\nUsing the `HateoasBuilder`, call the `setExpressionContextVariable()` method to add\r\nnew context variables:\r\n\r\n```php\r\nuse Hateoas\\HateoasBuilder;\r\n\r\n$hateoas = HateoasBuilder::create()\r\n    ->setExpressionContextVariable('foo', new Foo())\r\n    ->build();\r\n```\r\n\r\nThe `foo` variable is now available:\r\n\r\n```\r\nexpr(foo !== null)\r\n```\r\n\r\n### URL Generators\r\n\r\nSince you can use the [Expression Language](#the-expression-language) to define\r\nthe relations links (`href` key), you can do a lot by default. However if you\r\nare using a framework, chances are that you will want to use routes to build\r\nlinks.\r\n\r\nYou will first need to configure an `UrlGenerator` on the builder. You can\r\neither implement the `Hateoas\\UrlGenerator\\UrlGeneratorInterface`, or use the\r\n`Hateoas\\UrlGenerator\\CallableUrlGenerator`:\r\n\r\n```php\r\nuse Hateoas\\UrlGenerator\\CallableUrlGenerator;\r\n\r\n$hateoas = HateoasBuilder::create()\r\n    ->setUrlGenerator(\r\n        null, // By default all links uses the generator configured with the null name\r\n        new CallableUrlGenerator(function ($route, array $parameters, $absolute) use ($myFramework) {\r\n            return $myFramework->generateTheUrl($route, $parameters, $absolute);\r\n        })\r\n    )\r\n    ->build()\r\n;\r\n```\r\n\r\nYou will then be able to use the [@Route](#route) annotation:\r\n\r\n```php\r\nuse Hateoas\\Configuration\\Annotation as Hateoas;\r\n\r\n/**\r\n * @Hateoas\\Relation(\r\n *      \"self\",\r\n *      href = @Hateoas\\Route(\r\n *          \"user_get\",\r\n *          parameters = {\r\n *              \"id\" = \"expr(object.getId())\"\r\n *          }\r\n *      )\r\n * )\r\n */\r\nclass User\r\n```\r\n\r\n```json\r\n{\r\n    \"id\": 42,\r\n    \"first_name\": \"Adrien\",\r\n    \"last_name\": \"Brault\",\r\n    \"_links\": {\r\n        \"self\": {\r\n            \"href\": \"/api/users/42\"\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nNote that the library comes with a `SymfonyUrlGenerator`. For example, to use it\r\nin Silex:\r\n\r\n```php\r\nuse Hateoas\\UrlGenerator\\SymfonyUrlGenerator;\r\n\r\n$hateoas = HateoasBuilder::create()\r\n    ->setUrlGenerator(null, new SymfonyUrlGenerator($app['url_generator']))\r\n    ->build()\r\n;\r\n```\r\n\r\n### Helpers\r\n\r\nHateoas provides a set of helpers to ease the process of building APIs.\r\n\r\n#### LinkHelper\r\n\r\nThe `LinkHelper` class provides a `getLinkHref($object, $rel, $absolute = false)`\r\nmethod that allows you to get the _href_ value of any object, for any given\r\nrelation name.  Basically, it is able to generate a URI (either absolute or\r\nrelative) from any **link** relation:\r\n\r\n```php\r\n$user = new User(123, 'William', 'Durand');\r\n\r\n$linkHelper->getLinkHref($user, 'self');\r\n// /api/users/123\r\n\r\n$linkHelper->getLinkHref($user, 'self', true);\r\n// http://example.com/api/users/123\r\n```\r\n\r\n##### The `link` Function\r\n\r\nThe feature above is also available in your expressions (cf. [The Expression\r\nLanguage](#the-expression-language)) through the `link(object, rel, absolute)`\r\n**function**:\r\n\r\n```php\r\n/**\r\n * @Hateoas\\Relation(\r\n *     \"self\",\r\n *     href = @Hateoas\\Route(\"post_get\", parameters = {\"id\" = \"expr(object.getId())\"})\r\n * )\r\n */\r\nclass Post {}\r\n\r\n/**\r\n * @Hateoas\\Relation(\r\n *     \"self\",\r\n *     href = @Hateoas\\Route(\"user_get\", parameters = {\"id\" = \"expr(object.getId())\"})\r\n * )\r\n * @Hateoas\\Relation(\r\n *     \"post\",\r\n *     href = \"expr(link(object.getPost(), 'self', true))\"\r\n * )\r\n * @Hateoas\\Relation(\r\n *     \"relative\",\r\n *     href = \"expr(link(object.getRelativePost(), 'self'))\"\r\n * )\r\n */\r\nclass User\r\n{\r\n    ...\r\n\r\n    public function getPost()\r\n    {\r\n        return new Post(456);\r\n    }\r\n\r\n    public function getRelativePost()\r\n    {\r\n        return new Post(789);\r\n    }\r\n}\r\n```\r\n\r\nPay attention to the `href` expressions for the `post` and `relative` relations,\r\nas well as their corresponding values in the following JSON content:\r\n\r\n```json\r\n{\r\n    \"user\": {\r\n        \"id\": 123,\r\n        \"first_name\": \"William\",\r\n        \"last_name\": \"Durand\",\r\n        \"_links\": {\r\n            \"self\": { \"href\": \"http://example.com/api/users/123\" },\r\n            \"post\": { \"href\": \"http://example.com/api/posts/456\" },\r\n            \"relative\": { \"href\": \"/api/posts/789\" }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nIt is worth mentioning that you can **force** whether you want an absolute or\r\nrelative URI by using the third argument in both the `getLinkHref()` method and\r\nthe `link` function.\r\n\r\n**Important:** by default, all URIs will be **relative**, even those which are\r\ndefined as **absolute** in their configuration.\r\n\r\n```php\r\n$linkHelper->getLinkHref($user, 'post');\r\n// /api/posts/456\r\n\r\n$linkHelper->getLinkHref($user, 'post', true);\r\n// http://example.com/api/posts/456\r\n\r\n$linkHelper->getLinkHref($user, 'relative');\r\n// /api/posts/789\r\n\r\n$linkHelper->getLinkHref($user, 'relative', true);\r\n// http://example.com/api/posts/789\r\n```\r\n\r\n### Serializers & Formats\r\n\r\nHateoas provides a set of **serializers**. Each **serializer** allows you to\r\ngenerate either XML or JSON content following a specific **format**, such as\r\n[HAL](http://stateless.co/hal_specification.html), or [Atom\r\nLinks](http://tools.ietf.org/search/rfc4287#section-4.2.7) for instance.\r\n\r\n#### The JsonHalSerializer\r\n\r\nThe `JsonHalSerializer` allows you to generate HAL compliant relations in JSON.\r\nIt is the default JSON serializer in Hateoas.\r\n\r\nHAL provides its linking capability with a convention which says that a resource\r\nobject has a reserved property called `_links`. This property is an object that\r\ncontains links. These links are key'ed by their link relation.\r\n\r\nHAL also describes another convention which says that a resource may have\r\nanother reserved property named `_embedded`. This property is similar to `_links`\r\nin that embedded resources are key'ed by relation name. The main difference is\r\nthat rather than being links, the values are resource objects.\r\n\r\n![](http://stateless.co/info-model.png)\r\n\r\n```json\r\n{\r\n    \"message\": \"Hello, World!\",\r\n    \"_links\": {\r\n        \"self\": {\r\n            \"href\": \"/notes/0\"\r\n        }\r\n    },\r\n    \"_embedded\": {\r\n        \"associated_events\": [\r\n            {\r\n                \"name\": \"SymfonyCon\",\r\n                \"date\": \"2013-12-12T00:00:00+0100\"\r\n            }\r\n        ]\r\n    }\r\n}\r\n```\r\n\r\n#### The XmlSerializer\r\n\r\nThe `XmlHalSerializer` allows you to generate [Atom\r\nLinks](http://tools.ietf.org/search/rfc4287#section-4.2.7) into your XML\r\ndocuments. It is the default XML serializer.\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<note>\r\n    <message><![CDATA[Hello, World!]]></message>\r\n    <link rel=\"self\" href=\"/notes/0\" />\r\n    <events rel=\"associated_events\">\r\n        <event>\r\n            <name><![CDATA[SymfonyCon]]></name>\r\n            <date><![CDATA[2013-12-12T00:00:00+0100]]></date>\r\n        </event>\r\n    </events>\r\n</note>\r\n```\r\n\r\n#### The XmlHalSerializer\r\n\r\nThe `XmlHalSerializer` allows you to generate HAL compliant relations in XML.\r\n\r\nHAL in XML is similar to [HAL in JSON](#the-jsonhalserializer) in the sense that\r\nit describes `link` tags and `resource` tags.\r\n\r\n**Note:** the `self` relation will actually become an attribute of the main\r\nresource instead of being a `link` tag. Other links will be generated as `link`\r\ntags.\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<note href=\"/notes/0\">\r\n    <message><![CDATA[Hello, World!]]></message>\r\n\r\n    <resource rel=\"associated_events\">\r\n        <name><![CDATA[SymfonyCon]]></name>\r\n        <date><![CDATA[2013-12-12T00:00:00+0100]]></date>\r\n    </resource>\r\n</note>\r\n```\r\n\r\n#### Adding New Serializers\r\n\r\nFor JSON related formats, you must implement the `JsonSerializerInterface`\r\ninterface, and for XML related formats, you must implement the\r\n`XmlSerializerInterface`. Both interfaces describe two methods to serialize\r\n**links** and **embedded** relations.\r\n\r\n### The HateoasBuilder\r\n\r\nThe `HateoasBuilder` class is used to easily configure Hateoas thanks to a\r\npowerful and fluent API.\r\n\r\n```php\r\nuse Hateoas\\HateoasBuilder;\r\n\r\n$hateoas = HateoasBuilder::create()\r\n    ->setCacheDir('/path/to/cache/dir')\r\n    ->setDebug($trueOrFalse)\r\n    ->setDefaultXmlSerializer()\r\n    ...\r\n    ->build();\r\n```\r\n\r\nAll the methods below return the current builder, so that you can chain them.\r\n\r\n#### XML Serializer\r\n\r\n* `setXmlSerializer(XmlSerializerInterface $xmlSerializer)`: sets the XML\r\n  serializer to use. Default is: `XmlSerializer`;\r\n* `setDefaultXmlSerializer()`: sets the default XML serializer\r\n  (`XmlSerializer`).\r\n\r\n#### JSON Serializer\r\n\r\n* `setJsonSerializer(JsonSerializerInterface $jsonSerializer)`: sets the JSON\r\n  serializer to use. Default is: `JsonHalSerializer`;\r\n* `setDefaultJsonSerializer()`: sets the default JSON serializer\r\n  (`JsonHalSerializer`).\r\n\r\n#### URL Generator\r\n\r\n* `setUrlGenerator($name = null, UrlGeneratorInterface $urlGenerator)`: adds a\r\n  new named URL generator. If `$name` is `null`, the URL generator will be the\r\n  default one.\r\n\r\n#### Expression Evaluator/Expression Language\r\n\r\n* `setExpressionContextVariable($name, $value)`: adds a new expression context\r\n  variable;\r\n* `setExpressionLanguage(ExpressionLanguage $expressionLanguage)`.\r\n\r\n#### Relation Provider\r\n\r\n* `addRelationProviderResolver(RelationProviderResolverInterface $resolver)`:\r\n  adds a new relation provider resolver.\r\n\r\n#### (JMS) Serializer Specific\r\n\r\n* `includeInterfaceMetadata($include)`: whether to include the metadata from the\r\n  interfaces;\r\n* `setMetadataDirs(array $namespacePrefixToDirMap)`: sets a map of namespace\r\n  prefixes to directories. This method overrides any previously defined\r\n  directories;\r\n* `addMetadataDir($dir, $namespacePrefix = '')`: adds a directory where the\r\n  serializer will look for class metadata;\r\n* `addMetadataDirs(array $namespacePrefixToDirMap)`: adds a map of namespace\r\n  prefixes to directories;\r\n* `replaceMetadataDir($dir, $namespacePrefix = '')`: similar to\r\n  `addMetadataDir()`, but overrides an existing entry.\r\n\r\nPlease read the official [Serializer\r\ndocumentation](http://jmsyst.com/libs/serializer) for more details.\r\n\r\n#### Others\r\n\r\n* `setDebug($debug)`: enables or disables the debug mode;\r\n* `setCacheDir($dir)`: sets the cache directory.\r\n\r\n### Configuring a Cache Directory\r\n\r\nBoth the serializer and the Hateoas libraries collect metadata about your\r\nobjects from various sources such as YML, XML, or annotations. In order to make\r\nthis process as efficient as possible, it is recommended that you allow the\r\nHateoas library to cache this information. To do that, just configure a\r\ncache directory:\r\n\r\n```php\r\n$builder = \\Hateoas\\HateoasBuilder::create();\r\n\r\n$hateoas = $builder\r\n    ->setCacheDir($someWritableDir)\r\n    ->build();\r\n```\r\n\r\n### Configuring Metadata Locations\r\n\r\nHateoas supports several metadata sources. By default, it uses Doctrine\r\nannotations, but you may also store metadata in XML, or YAML files. For the\r\nlatter, it is necessary to configure a metadata directory where those files are\r\nlocated:\r\n\r\n```php\r\n$hateoas = \\Hateoas\\HateoasBuilder::create()\r\n    ->addMetadataDir($someDir)\r\n    ->build();\r\n```\r\n\r\nHateoas would expect the metadata files to be named like the fully qualified\r\nclass names where all `\\` are replaced with `.`. So, if you class would be\r\nnamed `Vendor\\Package\\Foo` the metadata file would need to be located at\r\n`$someDir/Vendor.Package.Foo.(xml|yml)`.\r\n\r\n\r\nReference\r\n---------\r\n\r\n### XML\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<serializer>\r\n<class name=\"Acme\\Demo\\Representation\\User\" h:providers=\"Class::getRelations, getRelations\" xmlns:h=\"https://github.com/willdurand/Hateoas\">\r\n        <h:relation rel=\"self\">\r\n            <h:href uri=\"http://acme.com/foo/1\" />\r\n        </h:relation>\r\n        <h:relation rel=\"expr(object.getFriendsDynamicRel())\">\r\n            <h:href router=\"user_friends\" generator=\"my_custom_generator\">\r\n                <h:parameter name=\"id\" value=\"expr(object.getId())\" />\r\n                <h:parameter name=\"page\" value=\"1\" />\r\n            </h:ref>\r\n            <h:embedded xml-element-name=\"users\">\r\n                <h:content>expr(object.getFriends())</h:content>\r\n                <h:exclusion ... />\r\n            </h:embedded>\r\n            <h:exclusion groups=\"Default, user_full\" since-version=\"1.0\" until-version=\"2.2\" exclude-if=\"expr(object.getFriends() === null)\" />\r\n        </h:relation>\r\n    </class>\r\n</serializer>\r\n```\r\nSee the\r\n[`hateoas.xsd`](https://github.com/willdurand/Hateoas/blob/master/hateoas.xsd)\r\nfile for more details.\r\n\r\n### YAML\r\n\r\n```yaml\r\nAcme\\Demo\\Representation\\User:\r\n    relations:\r\n        -   rel: self\r\n            href: http://acme.com/foo/1\r\n        -   rel: expr(object.getFriendsDynamicRel())\r\n            href:\r\n                route: user_friends\r\n                parameters:\r\n                    id: expr(object.getId())\r\n                    page: 1\r\n                generator: my_custom_generator\r\n            embedded:\r\n                content: expr(object.getFriends())\r\n                xmlElementName: users\r\n                exclusion: ...\r\n            exclusion:\r\n                groups: [Default, user_full]\r\n                since_version: 1.0\r\n                until_version: 2.2\r\n                exclude_if: expr(object.getFriends() === null)\r\n\r\n    relation_providers: [ 'Class::getRelations', 'getRelations' ]\r\n```\r\n\r\n### Annotations\r\n\r\n#### @Relation\r\n\r\nThis annotation can be defined on a class.\r\n\r\n```php\r\nuse Hateoas\\Configuration\\Annotation as Hateoas;\r\n\r\n/**\r\n * @Hateoas\\Relation(\r\n *     name = \"self\",\r\n *     href = \"http://hello\",\r\n *     embed = \"expr(object.getHello())\",\r\n *     attributes = { \"foo\" = \"bar\" },\r\n *     exclusion = ...,\r\n * )\r\n */\r\n```\r\n\r\n| Property   | Required               | Content                         | Expression language   |\r\n|------------|------------------------|---------------------------------|-----------------------|\r\n| name       | Yes                    | string                          | Yes                   |\r\n| href       | If embedded is not set | string / [@Route](#route)       | Yes                   |\r\n| embedded   | If href is not set     | string / [@Embedded](#embedded) | Yes                   |\r\n| attributes | No                     | array                           | Yes on key and values |\r\n| exclusion  | No                     | [@Exclusion](#exclusion)        | N/A                   |\r\n\r\n#### @Route\r\n\r\n```php\r\nuse Hateoas\\Configuration\\Annotation as Hateoas;\r\n\r\n/**\r\n * @Hateoas\\Relation(\r\n *     name = \"self\",\r\n *     href = @Hateoas\\Route(\r\n *         \"user_get\",\r\n *         parameters = { \"id\" = \"expr(object.getId())\" },\r\n *         absolute = true,\r\n *         generator = \"my_custom_generator\"\r\n *     )\r\n * )\r\n */\r\n```\r\n\r\nThis annotation can be defined in the **href** property of the\r\n[@Relation](#relation) annotation. This is allows you to your URL generator,\r\nif you have configured one.\r\n\r\n| Property   | Required            | Content        | Expression language             |\r\n|------------|---------------------|----------------|---------------------------------|\r\n| name       | Yes                 | string         | Yes                             |\r\n| parameters | Defaults to array() | array / string | Yes (string + array key/values) |\r\n| absolute   | Defaults to false   | boolean        | No                              |\r\n| generator  | No                  | string / null  | No                              |\r\n\r\n#### @Embedded\r\n\r\n```php\r\nuse Hateoas\\Configuration\\Annotation as Hateoas;\r\n\r\n/**\r\n * @Hateoas\\Relation(\r\n *     name = \"friends\",\r\n *     embedded = @Hateoas\\Embedded(\r\n *         \"expr(object.getFriends())\",\r\n *         exclusion = ...,\r\n *         xmlElementName = \"users\"\r\n *     )\r\n * )\r\n */\r\n```\r\n\r\nThis annotation can be defined in the **embedded** property of the\r\n[@Relation](#relation) annotation. It is useful if you need configure the\r\n`exclusion` or `xmlElementName` options for the embedded resource.\r\n\r\n| Property       | Required            | Content                  | Expression language    |\r\n|----------------|---------------------|--------------------------|------------------------|\r\n| content        | Yes                 | string / array           | Yes (string)           |\r\n| exclusion      | Defaults to array() | [@Exclusion](#exclusion) | N/A                    |\r\n| xmlElementName | Defaults to array() | string                   | Yes                    |\r\n\r\n#### @Exclusion\r\n\r\nThis annotation can be defined in the **exclusion** property of both the\r\n[@Relation](#relation) and [@Embedded](#embedded) annotations.\r\n\r\n| Property     | Required | Content          | Expression language    |\r\n|--------------|----------|------------------|------------------------|\r\n| groups       | No       | array            | No                     |\r\n| sinceVersion | No       | float / integer  | No                     |\r\n| untilVersion | No       | float / integer  | No                     |\r\n| maxDepth     | No       | integer          | No                     |\r\n| excludeIf    | No       | string / boolean | Yes                    |\r\n\r\nAll values except `excludeIf` act the same way as when they are used directly\r\non the regular properties with the serializer.\r\n\r\n`excludeIf` expects a boolean and is helpful when another expression would fail\r\nunder some circumstances. In this example, if the `getManager` method is `null`,\r\nyou should exclude it to prevent the URL generation from failing:\r\n\r\n```php\r\n/**\r\n * @Hateoas\\Relation(\r\n *     \"manager\",\r\n *     href = @Hateoas\\Route(\r\n *         \"user_get\",\r\n *         parameters = { \"id\" = \"expr(object.getManager().getId())\" }\r\n *     ),\r\n *     exclusion = @Hateoas\\Exclusion(excludeIf = \"expr(null === object.getManager())\")\r\n * )\r\n */\r\nclass User\r\n{\r\n    public function getId() {}\r\n\r\n    /**\r\n     * @return User|null\r\n     */\r\n    public function getManager() {}\r\n}\r\n```\r\n\r\n#### @RelationProvider\r\n\r\nThis annotation can be defined on a class.\r\n\r\n| Property | Required | Content | Expression language |\r\n|----------|----------|---------|---------------------|\r\n| name     | Yes      | string  | No                  |\r\n\r\nThe can be:\r\n\r\n- A method: `addRelations`\r\n- A static method: `Class::addRelations`\r\n- A Symfony2 service method: `acme_foo.service:addRelations`\r\n\r\n```php\r\nuse Hateoas\\Configuration\\Metadata\\ClassMetadataInterface;\r\nuse Hateoas\\Configuration as Hateoas;\r\n\r\nclass MyRelationProvider\r\n{\r\n    public function addRelations($object, ClassMetadataInterface $classMetadata)\r\n    {\r\n        // You need to return the relations\r\n        // Adding the relations to the $classMetadata won't work\r\n        return array(\r\n            new Hateoas\\Relation(\r\n                'self',\r\n                new Hateoas\\Route(\r\n                    'foo_get',\r\n                    array('id' => 'expr(object.getId())')\r\n                )\r\n            )\r\n        );\r\n    }\r\n}\r\n```\r\n\r\n\r\nInternals\r\n---------\r\n\r\nThis section refers to the Hateoas internals, providing documentation about\r\nhidden parts of this library. This is not always relevant for end users, but\r\ninteresting for developers or people interested in learning how things work\r\nunder the hood.\r\n\r\n### Expression Functions\r\n\r\n**Expression Functions** are custom functions used to extend the [Expression\r\nLanguage](#the-expression-language) as explained in the [Extending the\r\nExpressionLanguage](http://symfony.com/doc/current/components/expression_language/extending.html),\r\npart of the Symfony documentation.\r\n\r\nBy now, Hateoas does not let users add their own custom functions. Only core\r\nfunctions are registered, such as the `LinkExpressionFunction` described in\r\n[LinkHelper - The `link` Function](#the-link-function).\r\n\r\nThe `ExpressionFunctionInterface` is designed to represent an expression\r\nfunction. Adding a new expression function is a matter of implementing this\r\ninterface and registering it into the `ExpressionEvaluator` through the\r\n`registerFunction()` method.","google":"UA-46469869-1","note":"Don't delete this file! It's used internally to help with page regeneration."}